* Pfuture

** What it is

pfuture.el offers a set of simple functions extending Emacs' existing ~make-process~ functionality. It bundles
both a process and its output in a single struct - the "future" - making it conveniently easy to pass around to other
functions, wait for it to complete and access its output. In other words what this package offers is an asynchronous version
of ~shell-command-to-string~ without the need to deal with process creation and filter functions.

** How to use it

 * To create a future use ~pfuture-new~. It takes as input a list of strings which is the command to run and returns a
   ~pfuture~ struct made up of the two fields ~process~ and ~result~, both accessible through ~pfuture-process~ and
   ~pfuture-result~ respectively.

 * Alternatively you can use ~pfuture-new!~. It works the same as ~pfuture-new~, but as a macro its input needn't necessarily
   be strings. It converts its arguments to strings and then passes them on to ~pfuture-new~. It assumes that every arg
   given is either a symbol, a number, or a string and will throw an error if this is not the case.

   This allows you to write
   #+BEGIN_SRC emacs-lisp
     (pfuture-new! git status .)
   #+END_SRC
   instead of
   #+BEGIN_SRC emacs-lisp
     (pfuture-new "git" "status" ".")
   #+END_SRC

 * To wait for a future to produce a result use ~pfuture-await~. It takes as input the future to wait for as well as
   the optional keyword args ~:timeout~ (in s) and ~:just-this-one~ (see ~accept-process-output~) and returns the process
   output, or nil if the process did not finish within the given timeout. The output (or nil) will also be assgined to the
   future's ~result~ field.
   *Warning*:
   Be careful when asking for the exit status of a future's process - ~process-exit-status~ will return 0 for a process
   that has not yet finished. This might for example give you trouble when you expect to parse the output of a git process,
   the process seems to have an exit code of 0, but in fact will finish with exit code 128 since it wasn't launched in a
   git controlled direcotry. In such a case consider using ~pfuture-await-to-finish~ instead.

 * To keep waiting until the process is dead and finished use ~pfuture-await-to-finish~ which will keep reading while the
   process still lives as per ~process-live-p~ (and will thus block /forever/ if the process never finishes).

 * Finally ~pfufure-live-p~ is a convenience method to check if a future's process is still alive.

** Practical example

Given this artificially slow_status.sh bash script

#+BEGIN_SRC bash
  sleep 3 && git status
#+END_SRC

despite running the script twice the following code will execute within 3 seconds on account of being asynchronous:

#+BEGIN_SRC emacs-lisp
  (let ((start   (float-time))
        (future1 (pfuture-new "bash" "slow_status.sh"))
        (future2 (pfuture-new "bash" "slow_status.sh")))
    (pfuture-await future1 :timeout 4 :just-this-one nil)
    (pfuture-await future2 :timeout 4 :just-this-one nil)
    (message "Finished after %s seconds" (round (- (float-time) start))))
#+END_SRC
